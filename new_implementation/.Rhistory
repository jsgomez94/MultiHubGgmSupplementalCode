upper <- - min(L_bar) + 5
nu_range <- seq(lower, upper, length.out = 100)
vals <- lapply(
nu_range,
function(nu, lambda) {
exp(lambda + nu) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
sum() %>%
return()
},
lambda = L_bar
) %>% unlist()
min_ind <- which.min(abs(K - vals))
nu_opt <- nu_range[min_ind]
plot(nu_range, vals)
print(nu_opt)
L_update <- exp(L_bar + nu_opt) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
unlist()
return(L_update)
}
update_M(sigma_list, v0, v0, 1, 1, 1)
update_M(sigma_list, v0, v0, 1, 1, 1)
##
##  INPUT
##    L_bar : Eigenvalues and eigenvectors of the matrix
##            aggr_M.
##    K     : Number of populations of interest.
##    d     : dimension of the data.
##
##  OUTPUT
##
##
ev_hat <- function(L_bar, K, d) {
lower <- log(K / d) - max(L_bar)
upper <- - min(L_bar) + 5
nu_range <- seq(lower, upper, length.out = 100)
vals <- lapply(
nu_range,
function(nu, lambda) {
exp(lambda + nu) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
sum() %>%
return()
},
lambda = L_bar
) %>% unlist()
min_ind <- which.min(abs(K - vals))
nu_opt <- nu_range[min_ind]
plot(nu_range, vals)
print(nu_opt)
L_update <- exp(L_bar + nu_opt) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
unlist()
return(L_update)
}
update_M(sigma_list, v0, v0, 1, 1, 1)
##
##  INPUT
##    L_bar : Eigenvalues and eigenvectors of the matrix
##            aggr_M.
##    K     : Number of populations of interest.
##    d     : dimension of the data.
##
##  OUTPUT
##
##
ev_hat <- function(L_bar, K, d) {
lower <- log(K / d)
upper <- - min(L_bar) + 5
nu_range <- seq(lower, upper, length.out = 100)
vals <- lapply(
nu_range,
function(nu, lambda) {
exp(lambda + nu) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
sum() %>%
return()
},
lambda = L_bar
) %>% unlist()
min_ind <- which.min(abs(K - vals))
nu_opt <- nu_range[min_ind]
plot(nu_range, vals)
print(nu_opt)
L_update <- exp(L_bar + nu_opt) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
unlist()
return(L_update)
}
update_M(sigma_list, v0, v0, 1, 1, 1)
##
##  INPUT
##    L_bar : Eigenvalues and eigenvectors of the matrix
##            aggr_M.
##    K     : Number of populations of interest.
##    d     : dimension of the data.
##
##  OUTPUT
##
##
ev_hat <- function(L_bar, K, d) {
lower <- log(K / d) - 1
upper <- - min(L_bar)
nu_range <- seq(lower, upper, length.out = 100)
vals <- lapply(
nu_range,
function(nu, lambda) {
exp(lambda + nu) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
sum() %>%
return()
},
lambda = L_bar
) %>% unlist()
min_ind <- which.min(abs(K - vals))
nu_opt <- nu_range[min_ind]
plot(nu_range, vals)
print(nu_opt)
L_update <- exp(L_bar + nu_opt) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
unlist()
return(L_update)
}
update_M(sigma_list, v0, v0, 1, 1, 1)
update_w(sigma_list, v0, v0, 1, 1, 1)
update_M(sigma_list, v0, v0, 1, 1, 1)
plot(M)
library(plot.matrix)
plot(M)
K <- 3
p <- 10
w <- rep(1/K, K)
M <- diag(p) * K / p
v0 <- list(w = w, M = M)
Sigma1 <- diag(rep(c(5,1), c(K ,p - K)))
sigma_list <- list(Sigma1, Sigma1, Sigma1)
update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
library(plot.matrix)
plot(M)
M
Sigma1 <- diag(rep(c(5,1), c(K ,p - K)))
Sigma1
Sigma1 <- diag(rep(c(10,1), c(K ,p - K)))
sigma_list <- list(Sigma1, Sigma1, Sigma1)
update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
library(plot.matrix)
plot(M)
plot(dens(M))
plot(density(M))
##
##  INPUT
##    L_bar : Eigenvalues and eigenvectors of the matrix
##            aggr_M.
##    K     : Number of populations of interest.
##    d     : dimension of the data.
##
##  OUTPUT
##
##
ev_hat <- function(L_bar, K, d) {
lower <- log(K / d) - 1
upper <- - min(L_bar)
nu_range <- seq(lower, upper, length.out = 100)
vals <- lapply(
nu_range,
function(nu, lambda) {
exp(lambda + nu) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
sum() %>%
return()
},
lambda = L_bar
) %>% unlist()
min_ind <- which.min(abs(K - vals))
nu_opt <- nu_range[min_ind]
plot(nu_range, vals)
print(nu_opt)
L_update <- exp(L_bar + nu_opt) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
unlist()
print(L_update)
return(L_update)
}
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
library(plot.matrix)
plot(M)
plot(density(M))
####################################################
####################################################
## update_M :
##
##  INPUT
##
##  OUTPUT:
##
update_M <- function(sigma_list, vt, vt_bar, a, b, eta) {
log_M  <- log_mat(vt$M)
sigma_wmean <- mapply(
function(sigma, w) return(w * sigma),
sigma = sigma_list,
w = vt_bar$w) %>%
{Reduce('+', .)}
aggr_M <- (eta / a) * sigma_wmean + log_M
U_bar <- eigen(aggr_M)$vectors
L_bar <- eigen(aggr_M)$values
print(L_bar)
L_update <- ev_hat(L_bar,
length(sigma_list),
nrow(sigma_list[[1]]))
M_update <- U_bar %*% diag(L_update) %*% t(U_bar)
return(M_update)
}
K <- 3
p <- 10
w <- rep(1/K, K)
M <- diag(p) * K / p
v0 <- list(w = w, M = M)
Sigma1 <- diag(rep(c(10,1), c(K ,p - K)))
sigma_list <- list(Sigma1, Sigma1, Sigma1)
update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
####################################################
####################################################
## update_M :
##
##  INPUT
##
##  OUTPUT:
##
update_M <- function(sigma_list, vt, vt_bar, a, b, eta) {
log_M  <- log_mat(vt$M)
print(log_M)
sigma_wmean <- mapply(
function(sigma, w) return(w * sigma),
sigma = sigma_list,
w = vt_bar$w) %>%
{Reduce('+', .)}
print(sigma_wmean)
aggr_M <- (eta / a) * sigma_wmean + log_M
U_bar <- eigen(aggr_M)$vectors
L_bar <- eigen(aggr_M)$values
print(L_bar)
L_update <- ev_hat(L_bar,
length(sigma_list),
nrow(sigma_list[[1]]))
M_update <- U_bar %*% diag(L_update) %*% t(U_bar)
return(M_update)
}
K <- 3
p <- 10
w <- rep(1/K, K)
M <- diag(p) * K / p
v0 <- list(w = w, M = M)
Sigma1 <- diag(rep(c(10,1), c(K ,p - K)))
sigma_list <- list(Sigma1, Sigma1, Sigma1)
update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
####################################################
####################################################
## update_M :
##
##  INPUT
##
##  OUTPUT:
##
update_M <- function(sigma_list, vt, vt_bar, a, b, eta) {
K <- length(sigma_list)
p <- ncol(sigma_list[[1]])
log_M  <- log_mat(vt$M)
print(log_M)
sigma_w <- mapply(
function(sigma, w) return(w * sigma),
sigma = sigma_list,
w = vt_bar$w)
sigma_wmean <- matrix(0, p, p)
for (i in 1:K)
sigma_wmean <- sigma_wmean + sigma_w / K
aggr_M <- (eta / a) * sigma_wmean + log_M
U_bar <- eigen(aggr_M)$vectors
L_bar <- eigen(aggr_M)$values
print(L_bar)
L_update <- ev_hat(L_bar,
length(sigma_list),
nrow(sigma_list[[1]]))
M_update <- U_bar %*% diag(L_update) %*% t(U_bar)
return(M_update)
}
##
##  INPUT
##    L_bar : Eigenvalues and eigenvectors of the matrix
##            aggr_M.
##    K     : Number of populations of interest.
##    d     : dimension of the data.
##
##  OUTPUT
##
##
ev_hat <- function(L_bar, K, d) {
lower <- log(K / d) - 1
upper <- - min(L_bar)
nu_range <- seq(lower, upper, length.out = 100)
vals <- lapply(
nu_range,
function(nu, lambda) {
exp(lambda + nu) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
sum() %>%
return()
},
lambda = L_bar
) %>% unlist()
min_ind <- which.min(abs(K - vals))
nu_opt <- nu_range[min_ind]
plot(nu_range, vals)
print(nu_opt)
L_update <- exp(L_bar + nu_opt) %>%
{cbind(.,1)} %>%
apply(1, min) %>%
unlist()
print(L_update)
return(L_update)
}
update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
####################################################
####################################################
## update_M :
##
##  INPUT
##
##  OUTPUT:
##
update_M <- function(sigma_list, vt, vt_bar, a, b, eta) {
K <- length(sigma_list)
p <- ncol(sigma_list[[1]])
log_M  <- log_mat(vt$M)
print(log_M)
sigma_wmean <- matrix(0, p, p)
for (i in 1:K)
sigma_wmean <- sigma_wmean + vt_bar$w[k]* sigma[[k]] / K
aggr_M <- (eta / a) * sigma_wmean + log_M
U_bar <- eigen(aggr_M)$vectors
L_bar <- eigen(aggr_M)$values
print(L_bar)
L_update <- ev_hat(L_bar,
length(sigma_list),
nrow(sigma_list[[1]]))
M_update <- U_bar %*% diag(L_update) %*% t(U_bar)
return(M_update)
}
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
plot(M)
####################################################
####################################################
## update_M :
##
##  INPUT
##
##  OUTPUT:
##
update_M <- function(sigma_list, vt, vt_bar, a, b, eta) {
K <- length(sigma_list)
p <- ncol(sigma_list[[1]])
log_M  <- log_mat(vt$M)
print(log_M)
sigma_wmean <- matrix(0, p, p)
for (i in 1:K)
sigma_wmean <- sigma_wmean + vt_bar$w[k]* sigma_list[[k]] / K
print(sigma_wmean)
aggr_M <- (eta / a) * sigma_wmean + log_M
U_bar <- eigen(aggr_M)$vectors
L_bar <- eigen(aggr_M)$values
print(L_bar)
L_update <- ev_hat(L_bar,
length(sigma_list),
nrow(sigma_list[[1]]))
M_update <- U_bar %*% diag(L_update) %*% t(U_bar)
return(M_update)
}
K <- 3
p <- 10
w <- rep(1/K, K)
M <- diag(p) * K / p
v0 <- list(w = w, M = M)
Sigma1 <- diag(rep(c(10,1), c(K ,p - K)))
sigma_list <- list(Sigma1, Sigma1, Sigma1)
update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
####################################################
####################################################
## update_M :
##
##  INPUT
##
##  OUTPUT:
##
update_M <- function(sigma_list, vt, vt_bar, a, b, eta) {
K <- length(sigma_list)
p <- ncol(sigma_list[[1]])
log_M  <- log_mat(vt$M)
print(log_M)
sigma_wmean <- matrix(0, p, p)
for (k in 1:K)
sigma_wmean <- sigma_wmean + vt_bar$w[k]* sigma_list[[k]] / K
print(sigma_wmean)
aggr_M <- (eta / a) * sigma_wmean + log_M
U_bar <- eigen(aggr_M)$vectors
L_bar <- eigen(aggr_M)$values
print(L_bar)
L_update <- ev_hat(L_bar,
length(sigma_list),
nrow(sigma_list[[1]]))
M_update <- U_bar %*% diag(L_update) %*% t(U_bar)
return(M_update)
}
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
####################################################
####################################################
## update_M :
##
##  INPUT
##
##  OUTPUT:
##
update_M <- function(sigma_list, vt, vt_bar, a, b, eta) {
K <- length(sigma_list)
p <- ncol(sigma_list[[1]])
log_M  <- log_mat(vt$M)
print(log_M)
sigma_wmean <- matrix(0, p, p)
for (k in 1:K)
print(sigma_list[[k]])
sigma_wmean <- sigma_wmean + vt_bar$w[k] * sigma_list[[k]] / K
print(sigma_wmean)
aggr_M <- (eta / a) * sigma_wmean + log_M
U_bar <- eigen(aggr_M)$vectors
L_bar <- eigen(aggr_M)$values
L_update <- ev_hat(L_bar,
length(sigma_list),
nrow(sigma_list[[1]]))
M_update <- U_bar %*% diag(L_update) %*% t(U_bar)
return(M_update)
}
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
plot(M)
K <- 3
p <- 10
w <- rep(1/K, K)
M <- diag(p) * K / p
v0 <- list(w = w, M = M)
Sigma1 <- diag(c(10,5,5,rep(1, p - K)))
Sigma2 <- diag(c(5,10,5,rep(1, p - K)))
Sigma3 <- diag(c(5,5,10,rep(1, p - K)))
sigma_list <- list(Sigma1, Sigma2, Sigma3)
update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
library(plot.matrix)
plot(M)
plot(density(M))
K <- 3
p <- 10
w <- rep(1/K, K)
M <- diag(p) * K / p
v0 <- list(w = w, M = M)
Sigma1 <- diag(c(10,5,5,rep(1, p - K)))
Sigma2 <- diag(c(5,10,5,rep(1, p - K)))
Sigma3 <- diag(c(5,5,10,rep(1, p - K)))
sigma_list <- list(Sigma1, Sigma2, Sigma3)
w <- update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
w <- update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
w <- update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
w <- update_w(sigma_list, v0, v0, 1, 1, 1)
M <- update_M(sigma_list, v0, v0, 1, 1, 1)
v0 <- list(w = w, M = M)
library(plot.matrix)
plot(M)
plot(density(M))
